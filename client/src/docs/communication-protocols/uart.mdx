# UART Communication Protocol

**Universal Asynchronous Receiver/Transmitter (UART)** is one of the most widely used serial communication protocols in embedded systems due to its simplicity and reliability.

## Overview

UART is an asynchronous, serial communication protocol that uses two wires for data exchange:
- **TX (Transmit)** - Sends data from one device to another
- **RX (Receive)** - Receives data from another device

<Alert title="Key Feature">
  UART is asynchronous, meaning no clock signal is transmitted with the data. Instead, both sides must agree on timing parameters in advance.
</Alert>

## How UART Works

### Basic Concept

1. Data is transmitted as a series of bits one after another
2. Each character is packaged within a frame that includes start/stop bits and optional parity
3. The sender and receiver must operate at the same baud rate

### UART Frame Format

A typical UART frame consists of:

- 1 start bit (always low/0)
- 5-9 data bits (typically 8)
- Optional parity bit
- 1-2 stop bits (always high/1)

<Card title="UART Frame Visualization">
  ```
  Idle | Start | D0 | D1 | D2 | D3 | D4 | D5 | D6 | D7 | Parity | Stop | Idle
  HIGH | LOW   | X  | X  | X  | X  | X  | X  | X  | X  | X      | HIGH | HIGH
  ```
</Card>

### Baud Rate

The baud rate specifies how fast data is sent over the serial line, measured in bits per second (bps). Common baud rates include:

- 9600 bps
- 19200 bps
- 38400 bps
- 57600 bps
- 115200 bps

Both devices must use the same baud rate or communication will fail.

## UART Implementation

### Hardware Implementation

Most microcontrollers include built-in UART hardware peripherals. These handle the intricate timing requirements and bit framing automatically.

<Alert variant="warning" title="Hardware Considerations">
  When connecting UART devices, remember:
  - TX from one device connects to RX of the other device (and vice versa)
  - Ensure voltage levels are compatible between devices (may need level shifters)
  - Ground connections must be shared between devices
</Alert>

### Software Implementation (C Example)

<Tabs defaultValue="initialization">
  <TabsList>
    <TabsTrigger value="initialization">Initialization</TabsTrigger>
    <TabsTrigger value="transmit">Transmit</TabsTrigger>
    <TabsTrigger value="receive">Receive</TabsTrigger>
  </TabsList>
  
  <TabsContent value="initialization">
    ```c
    // Initialize UART with 8 data bits, no parity, 1 stop bit at 9600 baud
    void uart_init(void) {
      // Set baud rate
      UBRR0H = (uint8_t)(BAUD_PRESCALE >> 8);
      UBRR0L = (uint8_t)(BAUD_PRESCALE);
      
      // Enable transmitter and receiver
      UCSR0B = (1 << TXEN0) | (1 << RXEN0);
      
      // Set frame format: 8 data bits, no parity, 1 stop bit
      UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);
    }
    ```
  </TabsContent>
  
  <TabsContent value="transmit">
    ```c
    // Transmit a single character via UART
    void uart_transmit(uint8_t data) {
      // Wait for empty transmit buffer
      while (!(UCSR0A & (1 << UDRE0)));
      
      // Put data into buffer, sends the data
      UDR0 = data;
    }
    
    // Transmit a string via UART
    void uart_transmit_string(char* str) {
      while (*str) {
        uart_transmit(*str++);
      }
    }
    ```
  </TabsContent>
  
  <TabsContent value="receive">
    ```c
    // Receive a single character via UART
    uint8_t uart_receive(void) {
      // Wait for data to be received
      while (!(UCSR0A & (1 << RXC0)));
      
      // Get and return received data from buffer
      return UDR0;
    }
    
    // Receive a string via UART with timeout
    bool uart_receive_string(char* buffer, uint8_t max_length, uint16_t timeout_ms) {
      uint8_t i = 0;
      uint16_t timer = 0;
      
      while (i < max_length - 1) {
        if (UCSR0A & (1 << RXC0)) {
          buffer[i] = UDR0;
          if (buffer[i] == '\n' || buffer[i] == '\r') {
            break;
          }
          i++;
          timer = 0;
        } else {
          // Simple delay, would use a timer in real code
          _delay_ms(1);
          timer++;
          if (timer >= timeout_ms) {
            return false;  // Timeout
          }
        }
      }
      
      buffer[i] = '\0';  // Null terminate
      return true;
    }
    ```
  </TabsContent>
</Tabs>

## Advantages and Disadvantages

### Advantages

- Simple to implement (often requires just 2 wires)
- Supported by nearly all microcontrollers
- No clock signal required
- Buffer-based, allowing for reliable data transmission
- Available in hardware on most devices

### Disadvantages

- Limited to point-to-point communication (one sender, one receiver)
- Lower data rates compared to other protocols like SPI
- Both devices must maintain accurate timing
- No built-in flow control (though RTS/CTS can be added with additional wires)
- No acknowledgment mechanism

## Common Applications

- Debugging information output
- Communication with sensors
- GPS modules
- Bluetooth modules
- Communication between microcontrollers
- Command-line interfaces

## Common Issues and Troubleshooting

<Alert variant="warning" title="Troubleshooting UART">
  Common UART issues include:
  
  1. **Baud rate mismatch** - Ensure both devices use identical baud rates
  2. **Incorrect wiring** - TX connects to RX (and vice versa)
  3. **Voltage level incompatibility** - Use appropriate level shifters if needed
  4. **Framing errors** - Check for correct number of data bits, parity, and stop bits
  5. **Noise on the line** - Shorter wires and proper shielding can help
</Alert>

## Related Protocols

- **RS-232** - Standard for serial communication that uses UART with specific voltage levels
- **RS-485** - Industrial standard that allows for multiple devices and longer distances
- **TTL UART** - UART with Transistor-Transistor Logic voltage levels (typically 3.3V or 5V)

## Learn More

- [SPI Protocol](/docs/communication-protocols/spi)
- [IÂ²C Protocol](/docs/communication-protocols/i2c)
- [Microcontroller Peripherals](/docs/microcontrollers)