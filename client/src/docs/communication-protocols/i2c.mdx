# I2C Protocol

I2C (Inter-Integrated Circuit, pronounced "I-squared-C") is a synchronous, multi-master, multi-slave serial communication protocol designed for connecting low-speed peripherals to a microcontroller or processor.

## I2C Basics

I2C uses just two bidirectional wires for communication:
- **SDA (Serial Data Line)**: Carries the data
- **SCL (Serial Clock Line)**: Carries the clock signal

Both lines are pulled up with resistors, creating a wired-AND configuration where any device can pull the line LOW, but no device can drive it HIGH.

<Alert title="Pull-up Resistors">
  I2C requires pull-up resistors (typically 4.7kΩ) on both SDA and SCL lines. Without these resistors, the I2C bus will not function correctly.
</Alert>

## How I2C Works

I2C is a **master-slave** protocol where one or more master devices control one or more slave devices. Unlike SPI, I2C uses addressing to select specific devices.

### I2C Addressing

Each I2C slave device has a unique 7-bit (or 10-bit) address. This allows up to 128 devices (with 7-bit addressing) on a single I2C bus.

<Card title="Address Reservation">
  Some I2C addresses are reserved for special purposes:
  
  - 0x00: General call address
  - 0x01: START byte
  - 0x02: CBUS address
  - 0x03: Reserved for future use
  - 0x04-0x07: Reserved for Hs-mode
  - 0x78-0x7B: 10-bit slave addressing
  - 0x7C-0x7F: Reserved for future use
</Card>

### I2C Transaction Sequence

A typical I2C transaction consists of these steps:

1. **START condition**: SDA transitions from HIGH to LOW while SCL is HIGH
2. **Address transmission**: 7-bit address followed by a read/write bit
3. **Acknowledgment (ACK)**: Slave pulls SDA LOW to acknowledge
4. **Data transmission**: 8-bit data bytes with ACK after each byte
5. **STOP condition**: SDA transitions from LOW to HIGH while SCL is HIGH

<Card title="I2C Transaction Format">
  ```
  START | ADDR+R/W | ACK | DATA | ACK | DATA | ACK | ... | STOP
  ```
  
  - The master sends the 7-bit slave address + 1 bit for read (1) or write (0)
  - The slave with the matching address sends an ACK
  - Data bytes are transmitted, each followed by an ACK
  - The master sends a STOP condition to end the transaction
</Card>

## I2C Timing Diagram

<Card title="I2C Timing">
  ```
  SDA    ̅̅ ̅\_____/̅̅ ̅̅ ̅\_____/̅̅ ̅̅ ̅\___/̅̅ ̅̅ ̅\_____/̅̅ ̅̅ ̅
         |  A6  | A5  | A4  | A3  | A2  | A1  | A0  | R/W | ACK | D7  | ...
  SCL    ̅̅ ̅\_/̅̅ ̅\_/̅̅ ̅\_/̅̅ ̅\_/̅̅ ̅\_/̅̅ ̅\_/̅̅ ̅\_/̅̅ ̅\_/̅̅ ̅\_/̅̅ ̅\_/̅̅ ̅
         S                                                              
  ```
  
  - S: START condition
  - A0-A6: Address bits
  - R/W: Read/Write bit (1 for read, 0 for write)
  - ACK: Acknowledgment bit (0 for ACK, 1 for NACK)
  - D0-D7: Data bits
</Card>

## I2C Implementation in C

Here's a basic example of I2C initialization and data exchange on an AVR microcontroller:

```c
#include <avr/io.h>
#include <util/twi.h>

#define F_CPU 16000000UL  // CPU frequency
#define SCL_CLOCK 100000L // I2C clock speed (100 kHz)

void i2c_init(void) {
  // Set SCL frequency
  TWSR = 0x00; // Prescaler = 1
  TWBR = ((F_CPU/SCL_CLOCK)-16)/2;
}

uint8_t i2c_start(uint8_t address) {
  // Send START condition
  TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
  
  // Wait for TWINT Flag to be set
  while (!(TWCR & (1<<TWINT)));
  
  // Check if START was sent successfully
  if ((TWSR & 0xF8) != TW_START && (TWSR & 0xF8) != TW_REP_START) {
    return 1; // Error
  }
  
  // Send device address
  TWDR = address;
  TWCR = (1<<TWINT) | (1<<TWEN);
  
  // Wait for TWINT Flag to be set
  while (!(TWCR & (1<<TWINT)));
  
  // Check if address was acknowledged
  if ((TWSR & 0xF8) != TW_MT_SLA_ACK && (TWSR & 0xF8) != TW_MR_SLA_ACK) {
    return 2; // Error
  }
  
  return 0; // Success
}

void i2c_stop(void) {
  // Send STOP condition
  TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
  
  // Wait for STOP to be executed
  while (TWCR & (1<<TWSTO));
}

uint8_t i2c_write(uint8_t data) {
  // Load data into TWDR register
  TWDR = data;
  // Start transmission
  TWCR = (1<<TWINT) | (1<<TWEN);
  
  // Wait for TWINT Flag to be set
  while (!(TWCR & (1<<TWINT)));
  
  // Check if data was acknowledged
  if ((TWSR & 0xF8) != TW_MT_DATA_ACK) {
    return 1; // Error
  }
  
  return 0; // Success
}

uint8_t i2c_read_ack(void) {
  // Start reception with ACK
  TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
  
  // Wait for TWINT Flag to be set
  while (!(TWCR & (1<<TWINT)));
  
  // Return received data
  return TWDR;
}

uint8_t i2c_read_nack(void) {
  // Start reception with NACK (last byte)
  TWCR = (1<<TWINT) | (1<<TWEN);
  
  // Wait for TWINT Flag to be set
  while (!(TWCR & (1<<TWINT)));
  
  // Return received data
  return TWDR;
}

// Example: Write a byte to a slave device's register
uint8_t i2c_write_register(uint8_t slave_addr, uint8_t reg_addr, uint8_t data) {
  uint8_t status;
  
  // Start communication with slave
  status = i2c_start(slave_addr << 1); // Shift address for write
  if (status) return status;
  
  // Send register address
  status = i2c_write(reg_addr);
  if (status) {
    i2c_stop();
    return status;
  }
  
  // Send data
  status = i2c_write(data);
  
  // End communication
  i2c_stop();
  
  return status;
}
```

## I2C Speed Modes

I2C has several standard speed modes:

- **Standard mode**: 100 kHz
- **Fast mode**: 400 kHz
- **Fast mode plus**: 1 MHz
- **High-speed mode**: 3.4 MHz

<Alert title="Speed Limitations" variant="warning">
  Not all I2C devices support high-speed modes. Always check the device datasheet for supported speeds and ensure all devices on the bus can handle the selected speed.
</Alert>

## Advanced I2C Features

### Clock Stretching

I2C allows slaves to hold SCL low to delay the next clock cycle, giving them more time to process data. This is called clock stretching.

### Multi-Master Support

I2C allows multiple masters on the same bus, with arbitration to prevent data corruption if two masters attempt to communicate simultaneously.

### 10-bit Addressing

For systems with many devices, I2C supports 10-bit addressing, allowing up to 1024 devices on a single bus.

## Common I2C Interview Questions

1. **What are the main differences between I2C and SPI?**
   - I2C uses 2 wires for any number of devices; SPI requires an additional SS line for each device
   - I2C has addressing; SPI uses dedicated chip select lines
   - I2C is half-duplex; SPI is full-duplex
   - I2C is generally slower than SPI

2. **How does I2C support multiple devices on the same bus?**
   - Each device has a unique address
   - The master includes the target device's address in each transaction

3. **What is clock stretching in I2C?**
   - It's a mechanism for slaves to slow down communication
   - The slave holds SCL low to extend the current clock cycle
   - The master must wait until SCL goes high again before continuing

4. **What happens if two I2C masters try to use the bus simultaneously?**
   - I2C includes arbitration to resolve conflicts
   - A master loses arbitration if it tries to send a 1 (release SDA) while another master is sending a 0 (pulling SDA low)
   - The losing master backs off and retries later

5. **Why are pull-up resistors required for I2C?**
   - I2C uses open-drain/open-collector drivers that can only pull the lines LOW
   - Pull-up resistors are needed to bring the lines back HIGH when no device is pulling them LOW

## Advantages and Disadvantages

### Advantages
- Only two wires required regardless of the number of devices
- Built-in addressing system
- Multi-master capability
- No dedicated SS lines required
- Well-established standard with wide support

### Disadvantages
- Slower than SPI
- More complex protocol
- Half-duplex only
- Requires pull-up resistors
- Address conflicts can occur with some devices

## Common I2C Devices

I2C is widely used in various devices such as:
- EEPROM and flash memory
- Real-time clocks
- Temperature sensors
- Acceleration/motion sensors
- Display controllers
- IO expanders
- DACs and ADCs

## Further Learning

- [Return to Communication Protocols](/docs/communication-protocols)
- Learn about [UART](/docs/communication-protocols/uart) or [SPI](/docs/communication-protocols/spi)
- Check out the [Getting Started](/docs/getting-started) guide